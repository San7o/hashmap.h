//////////////////////////////////////////////////////////////////////
// SPDX-License-Identifier: MIT
//
// hashmap.h
// ===========
//
// Header-only implementation of an hashmap in C99 for any type.
//
// Author:  Giovanni Santini
// Mail:    giovanni.santini@proton.me
// License: MIT
//
//
// Documentation
// -------------
//
// This is an hashmap implementation with linked list buckets. Values
// are deep copied when added to the map using a function specified by
// the user, and are freed when removed / destroyed with another user
// function. This implementation is based on the symbol hashmap in
// https://github.com/San7o/haplolang.
//
// Api:
//
//    HASHMAP_DECLARE(prefix, hash_fn, key_type, value_type,
//                    value_deep_copy_fn, value_free_fn)
//      Declare an hashmap for value_type
//      Args:
//        - prefix: define a prefix for the hashmap functions and types.
//        - hash_fn: an hash function. Must have the signature:
//
//             hashmap_hash_t hash_fn(key_type key, unsigned int key_len);
//
//        - key_type: type of the key (that will get hashed)
//        - value_type: type of the value held in the hashmap
//        - value_deep_copy_fn: function to deep copy a value. Must
//          have the signature:
//
//             value_type value_deep_copy_fn(value_type *val);
//
//        - value_free_fn: free a value. Must have the signature:
//
//             void value_free_fn(value_type *val);
//
//    hashmap_hash_t
//       Type of an hash. An hash function is expected to return this,
//       or a type error will be generated by the compiler.
//
//    prefix_map_list
//       Hashmap bucket type
//
//    prefix_map
//       The hashmap type
//
//    int prefix_map_init(prefix_map *map, int capacity);
//        Initialize a [map] with [capacity]
//        Returns: 0 on success, or a negative HASHMAP_ERROR_ on error.
//        Note: You should destroy it when you are done.
//
//     int prefix_map_destroy(prefix_map *map);
//        Destroy a previously initialized [map]
//        Returns: 0 on success, or a negative HASHMAP_ERROR_ on failure.
// 
//     prefix_map* prefix_map_deep_copy(prefix_map *map);
//        Create a new deep copy of [map]
//        Returns: a deep copy of [map]
//        Note: Remember to also destroy the copy when you are done.
//
//     value_type*
//     prefix_map_lookup(prefix_map *map,
//                       key_type key,
//                       unsigned int key_len);
//        Lookup a [key] of [key_len] length in [map]
//        Returns: a pointer to the value if present, or NULL otherwise.
//
//     int prefix_map_update(prefix_map *map,
//                           key_type key,
//                           unsigned int key_len,
//                           value_type *value);
//        Insert / Update [value] with [key] of [ley_len] length in
//        [map]
//        Returns a positive value on success, which is either 0 if a
//        new value was added or 1 if an existing value was modified,
//        or a negative HASHMAP_ERROR_ in case of an error.
//
//     int prefix_map_delete(prefix_map *map,
//                           key_type key,
//                           unsigned int key_len)
//
//        Delete an entry with [key] of [key_len] length in [map]
//        Returns 0 on success, or a negative HASHMAP_ERROR_ on error.
//
//     hashmap_hash_t hashmap_hash_char(char *bytes, unsigned int len);
//     hashmap_hash_t hashmap_hash_int32(uint32_t a, unsigned int ignored);
//       Some sample hash functions, so you don't have to re-implement
//       them yourself. Check out micro-hash.h (github@San7o) for more
//       hashes.
//
// Non user facing apis:
//
//     prefix_map_list_free(prefix_map_list *list)
//     prefix_map_list* prefix_map_list_deep_copy(prefix_map_list *list)
//
//
// Usage
// -----
//
// Just #include "hashmap.h".
//
// If you want to use the built-in hash functions, you need to also
//
//    #define HASHMAP_IMPLEMENTATION
//
// before including the header.
//
// You can tune the library by #defining the allocator and free
// functions. See the "Config" comments under "Configuration" below.
//
// To start using an hashmap, you first need to declare one with the
// macro HASHMAP_DECLARE. For example:
//
//    HASHMAP_DECLARE(example, hashmap_hash_char, char*,
//                    ExampleType, example_deep_copy, example_free)
//
// Now you can start using the functions prefixed with "example".
//
//     example_map map;
//     example_map_init(&map, 1024);  // initialize
//
//     ExampleType example_value = {
//        .a = 10,
//        .b = "it just works",
//     };
//     example_map_update(&map, "example", strlen("example"), &example_value);
//
//     ExampleType *value = example_map_lookup(&map, "example", 8);
//     assert(value != NULL);
//     assert(value->a == 10);
//     assert(value->b == example.b);
//  
//     example_map_destroy(&map);     // destroy
//
// See full example at the end of the header.
//
//
// Code
// ----
//
// The official git repository of hashmap.h is hosted at:
//
//     https://github.com/San7o/hashmap.h
//
// This is part of a bigger collection of header-only C99 libraries
// called "micro-headers", contributions are welcome:
//
//     https://github.com/San7o/micro-headers
//


#ifndef HASHMAP
#define HASHMAP

#define HASHMAP_MAJOR 0
#define HASHMAP_MINOR 1

#ifdef __cplusplus
extern "C" {
#endif

//
// Configuration
//

// Config: The type of an hash
#ifndef HASHMAP_HASH_T
  #define HASHMAP_HASH_T unsigned long
#endif
  
// Config: Define memory allocation function
// Notes: This is expected to be used like calloc(3), and zero the memory
#ifndef HASHMAP_CALLOC
  #include <stdlib.h>
  #define HASHMAP_CALLOC calloc
#endif

// Config: Define memory free function
// Notes: This is expected to be used like free(3)
#ifndef HASHMAP_FREE
  #include <stdlib.h>
  #define HASHMAP_FREE free
#endif

// Config: Prefix for all functions
#ifndef HASHMAP_DEF
  #define HASHMAP_DEF static inline
#endif
  
//
// Macros
//

#include <stdbool.h>
#include <stdint.h>

#define HASHMAP_OK                0
#define HASHMAP_ERROR_MAP_NULL   -1
#define HASHMAP_ERROR_ALLOCATION -2
#define HASHMAP_ERROR_MAP_UNINITIALIZED -3
  
typedef HASHMAP_HASH_T hashmap_hash_t;
  
#define HASHMAP_DECLARE(prefix,                                         \
                        hash_fn,                                        \
                        key_type,                                       \
                        value_type,                                     \
                        value_deep_copy_fn,                             \
                        value_free_fn)                                  \
  typedef hashmap_hash_t (prefix##_map_hash)(key_type, unsigned int);   \
                                                                        \
  typedef value_type (prefix##_map_##value_type##_deep_copy)(value_type*); \
                                                                        \
  typedef struct prefix##_map_list prefix##_map_list;                   \
                                                                        \
  struct prefix##_map_list {                                            \
    hashmap_hash_t key_hash;                                            \
    prefix##_map_list *next;                                            \
    value_type val;                                                     \
  };                                                                    \
                                                                        \
  typedef struct {                                                      \
    prefix##_map_list **_map;                                           \
    int capacity;                                                       \
    prefix##_map_hash *hash;                                            \
    prefix##_map_##value_type##_deep_copy *value_type##_deep_copy;      \
  } prefix##_map;                                                       \
                                                                        \
  HASHMAP_DEF void prefix##_map_list_free(prefix##_map_list *list)      \
  {                                                                     \
    if (!list) return;                                                  \
                                                                        \
    prefix##_map_list *next = list->next;                               \
    prefix##_map_list_free(next);                                       \
    value_free_fn(&list->val);                                          \
    HASHMAP_FREE(list);                                                 \
                                                                        \
    return;                                                             \
  }                                                                     \
                                                                        \
  HASHMAP_DEF prefix##_map_list*                                        \
  prefix##_map_list_deep_copy(prefix##_map_list *list)                  \
  {                                                                     \
    if (!list) return NULL;                                             \
                                                                        \
    prefix##_map_list *new_list = HASHMAP_CALLOC(1, sizeof(prefix##_map_list)); \
    if (!new_list) return NULL;                                         \
                                                                        \
    new_list->val = value_deep_copy_fn(&list->val);                     \
    new_list->key_hash = list->key_hash;                                \
    new_list->next = prefix##_map_list_deep_copy(list->next);           \
                                                                        \
    return new_list;                                                    \
  }                                                                     \
                                                                        \
  HASHMAP_DEF int prefix##_map_init(prefix##_map *map, int capacity)    \
  {                                                                     \
    if (!map) return HASHMAP_ERROR_MAP_NULL;                            \
                                                                        \
    map->capacity = capacity;                                           \
    map->hash = hash_fn;                                                \
    map->value_type##_deep_copy = value_deep_copy_fn;                   \
    map->_map = HASHMAP_CALLOC(capacity, sizeof(prefix##_map_list*));   \
    if (map->_map == NULL) return HASHMAP_ERROR_ALLOCATION;             \
                                                                        \
    return HASHMAP_OK;                                                  \
  }                                                                     \
                                                                        \
  HASHMAP_DEF int prefix##_map_destroy(prefix##_map *map)               \
  {                                                                     \
    if (!map) return HASHMAP_ERROR_MAP_NULL;                            \
    if (!map->_map) return HASHMAP_OK;                                  \
                                                                        \
    for (int i = 0; i < map->capacity; ++i)                             \
    {                                                                   \
      prefix##_map_list_free(map->_map[i]);                             \
      map->_map[i] = NULL;                                              \
    }                                                                   \
                                                                        \
    HASHMAP_FREE(map->_map);                                            \
    map->_map = NULL;                                                   \
    return HASHMAP_OK;                                                  \
  }                                                                     \
                                                                        \
  HASHMAP_DEF prefix##_map*                                             \
  prefix##_map_deep_copy(prefix##_map *map)                             \
  {                                                                     \
    if (!map) return NULL;                                              \
                                                                        \
    prefix##_map *map_copy = HASHMAP_CALLOC(1, sizeof(prefix##_map));   \
    if (!map_copy) return NULL;                                         \
                                                                        \
    if (map->capacity == 0) return map_copy;                            \
                                                                        \
    map_copy->capacity = map->capacity;                                 \
    map_copy->hash = map->hash;                                         \
    map_copy->value_type##_deep_copy = map->value_type##_deep_copy;     \
    map_copy->_map = calloc(sizeof(prefix##_map_list*), map->capacity); \
                                                                        \
    for (int i = 0; i < map->capacity; ++i)                             \
    {                                                                   \
      map_copy->_map[i] = prefix##_map_list_deep_copy(map->_map[i]);    \
    }                                                                   \
                                                                        \
    return map_copy;                                                    \
  }                                                                     \
                                                                        \
  HASHMAP_DEF value_type*                                               \
  prefix##_map_lookup(prefix##_map *map,                                \
                      key_type key,                                     \
                      unsigned int key_len)                             \
  {                                                                     \
    if (!map) return NULL;                                              \
    if (!map->_map) return NULL;                                        \
                                                                        \
    hashmap_hash_t hash = hash_fn(key, key_len) % map->capacity;        \
                                                                        \
    prefix##_map_list *list = map->_map[hash];                          \
    bool found = false;                                                 \
    while (list)                                                        \
    {                                                                   \
      if (hash == list->key_hash)                                       \
      {                                                                 \
        found = true;                                                   \
        break;                                                          \
      }                                                                 \
      list = list->next;                                                \
    }                                                                   \
                                                                        \
    if (found) return &list->val;                                       \
                                                                        \
    return NULL;                                                        \
  }                                                                     \
                                                                        \
  HASHMAP_DEF int                                                       \
  prefix##_map_update(prefix##_map *map,                                \
                      key_type key,                                     \
                      unsigned int key_len,                             \
                      value_type *value)                                \
  {                                                                     \
    if (!map) return HASHMAP_ERROR_MAP_NULL;                            \
    if (!map->_map) return HASHMAP_ERROR_MAP_UNINITIALIZED;             \
                                                                        \
    hashmap_hash_t hash = hash_fn(key, key_len) % map->capacity;        \
                                                                        \
     prefix##_map_list *list = map->_map[hash];                         \
     if (!list)                                                         \
     {                                                                  \
       list = HASHMAP_CALLOC(1, sizeof(prefix##_map_list));             \
       if (!list) return HASHMAP_ERROR_ALLOCATION;                      \
       list->next = NULL;                                               \
       list->val = value_deep_copy_fn(value);                           \
       list->key_hash = hash;                                           \
       map->_map[hash] = list;                                          \
       return 0;                                                        \
     }                                                                  \
                                                                        \
     if (list->key_hash == hash)                                        \
     {                                                                  \
       value_free_fn(&list->val);                                       \
       list->val = value_deep_copy_fn(value);                           \
       return 1;                                                        \
     }                                                                  \
                                                                        \
     bool found = false;                                                \
     do {                                                               \
       list = list->next;                                               \
       if (list->key_hash == hash)                                      \
       {                                                                \
         found = true;                                                  \
         break;                                                         \
       }                                                                \
     } while (list->next);                                              \
                                                                        \
     if (found)                                                         \
     {                                                                  \
       value_free_fn(&list->val);                                       \
       list->val = value_deep_copy_fn(value);                           \
       return 1;                                                        \
     }                                                                  \
                                                                        \
     prefix##_map_list* new_list =                                      \
       HASHMAP_CALLOC(1, sizeof(prefix##_map_list));                    \
     if (!new_list) return HASHMAP_ERROR_ALLOCATION;                    \
     new_list->next = NULL;                                             \
     new_list->val = value_deep_copy_fn(value);                         \
     new_list->key_hash = hash;                                         \
     list->next = new_list;                                             \
                                                                        \
     return 0;                                                          \
  }                                                                     \
                                                                        \
  HASHMAP_DEF int                                                       \
  prefix##_map_delete(prefix##_map *map,                                \
                       key_type key,                                    \
                       unsigned int key_len)                            \
  {                                                                     \
    if (!map) return HASHMAP_ERROR_MAP_NULL;                            \
    if (!map->_map) return HASHMAP_ERROR_MAP_UNINITIALIZED;             \
                                                                        \
    hashmap_hash_t hash = hash_fn(key, key_len) % map->capacity;        \
                                                                        \
    prefix##_map_list *list = map->_map[hash];                          \
    if (list->key_hash == hash)                                         \
    {                                                                   \
      map->_map[hash] = list->next;                                     \
      HASHMAP_FREE(list);                                               \
      return HASHMAP_OK;                                                \
    }                                                                   \
                                                                        \
    bool found = false;                                                 \
    prefix##_map_list *prev;                                            \
    do {                                                                \
      prev = list;                                                      \
      list = list->next;                                                \
      if (list->key_hash == hash)                                       \
      {                                                                 \
        found = true;                                                   \
        break;                                                          \
      }                                                                 \
    } while (list);                                                     \
                                                                        \
    if (found)                                                          \
    {                                                                   \
      prev->next = list->next;                                          \
      HASHMAP_FREE(list);                                               \
      return HASHMAP_OK;                                                \
    }                                                                   \
                                                                        \
    return HASHMAP_OK;                                                  \
  }

//
// Function Declarations
//

// Some sample hash functions
// You need to #define HASHMAP_IMPLEMENTATION to use them.
  
// char* key hash function
// Credits to http://www.cse.yorku.ca/~oz/hash.html
HASHMAP_DEF unsigned long hashmap_hash_char(char *bytes, unsigned int len);

// uint32_t key hash function
HASHMAP_DEF uint32_t hashmap_hash_int32(uint32_t a, unsigned int ignored);
  
//
// Implementation
//

#ifdef HASHMAP_IMPLEMENTATION

HASHMAP_DEF unsigned long hashmap_hash_char(char *bytes, unsigned int len)
{
  unsigned long hash = 5381;
  for (unsigned int i = 0; i < len; ++i)
    hash = hash * 33 + bytes[i];
  return hash;
}

HASHMAP_DEF uint32_t hashmap_hash_int32(uint32_t a, unsigned int ignored)
{
    a = (a ^ 61) ^ (a >> 16);
    a = a + (a << 3);
    a = a ^ (a >> 4);
    a = a * 0x27d4eb2d;
    a = a ^ (a >> 15);
    return a;
}

#endif // HASHMAP_IMPLEMENTATION

//
// Examples
//

#if 0

#define HASHMAP_IMPLEMENTATION
#include "hashmap.h"

#include <stdio.h>
#include <assert.h>

// A custom type
typedef struct {
  int a;
  char* b;
} ExampleType;

// Define deep copy and free functions
ExampleType example_deep_copy(ExampleType *type) {
  printf("Deep copy\n"); return *type;
}
void example_free(ExampleType *type) {
  printf("Free\n"); return;
}

// Declare the hashmap
HASHMAP_DECLARE(example,
                hashmap_hash_char,
                char*,
                ExampleType,
                example_deep_copy,
                example_free)

int main(void)
{
  example_map map;
  assert(example_map_init(&map, 1024) == 0);

  ExampleType example = {
    .a = 10,
    .b = "it just works",
  };
  assert(example_map_update(&map, "example", 8, &example) == 0);

  ExampleType *value = example_map_lookup(&map, "example", 8);
  assert(value != NULL);
  assert(value->a == 10);
  assert(value->b == example.b);
  
  assert(example_map_destroy(&map) == 0);
  return 0;
}
  
#endif // 0
  
#ifdef __cplusplus
}
#endif

#endif // HASHMAP
